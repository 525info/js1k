<!doctype html>
<html>
    <head>
        <title>Raycaster</title>
        <meta charset="utf-8" />
        <style>
            #fps {
                position: absolute;
                top: 0;
            }
            #coords {
                position: absolute;
                top: 20px;
            }
        </style>
    </head>
    <body style="margin: 0px; overflow: hidden; background-color: #fff">
        <canvas></canvas>
        <div id="fps"></div>
        <div id="coords"></div>
        <script>
            var a = document.getElementsByTagName('canvas')[0];
            var b = document.body;
            var d = function(e) { return function() { e.parentNode.removeChild(e) } }(a);

            // unprefix some popular vendor prefixed things (but stick to their original name)
            var AudioContext = window.AudioContext
                || window.webkitAudioContext;
            var requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(f) { setTimeout(f, 1000/30) };

            // stretch canvas to screen size (once, wont onresize!)
            a.style.width = (a.width = innerWidth) + 'px';
            a.style.height = (a.height = innerHeight) + 'px';
            var c = a.getContext('2d');
        </script>
        <script>
            H = (c.width = a.height)/2;
            M = [];
            N = 1<<4;
            A = Math.PI/4;
            S = 1;
            Z = 30;
            V = 1;
            D = N;
            B = 0;
            K = 0; // 4 bits: left|up|right|down
            R = [];

            for (
                k = 0;
                k < N;
            )
                R.push(N*Math.random(k++), N*Math.random(k++));

            for (
                i = 0;
                i < N;
                i++
            )
                for (
                    M[i] = [], z1 = j = 0;
                    j < N;
                    j++
                ) {
                    x = i - N/2;
                    y = j - N/2;
                    M[i][j] = [z2 = 10*Math.exp(-(x*x+y*y)/20), 0|4/(Math.abs(z1-z2)+.25)];
                    z1 = z2;
                }

            //throw '';
            R = [];

            // rendering procedure ----------------------------------------
            X = N/2-D*.6*Math.cos(A);
            Y = N/2-D*.6*Math.sin(A);

            a.width = a.width; // canvas white reset

            for (
                k = 0;
                k < 32;
            )
                R[k++] = [];

            NN = 2000;
            for (
                nn = 0, k = 0;
                k < 2*H;
                k += S, nn++
            ) {
                r = A+(1-k/H)/2;

                E = 1/Math.abs(v = Math.cos(r)*H);
                F = 1/Math.abs(w = Math.sin(r)*H);
                c1 = M[I = 0|X][J = 0|Y];
                x = X-I;
                y = Y-J;
                e = x ? E*(v > 0 ? 1-x : x) : E;
                f = y ? F*(w > 0 ? 1-y : y) : F;

                m = n = 2*H; // current screen y coordinate
                p = q = 0; // current color

                (nn == NN) && console.log(I, J, 0, c1, 0, z1, E, F);

                for (
                    d = 0;
                    d < 8*D/H;
                ) {
                    (nn == NN) && console.log(e, f, e < f ? 'di < dj' : 'di >= dj');

                    if (e < f) {
                        x = v < 0;
                        y += e*w;
                        d += e;
                        f -= e;
                        e = E;

                        h = y*M[(x ? I-- : ++I)%N][(J+1)%N][0];
                        c2 = M[I%N][J%N];
                        h += (1-y)*(x ? c1 : c2)[0];
                    } else {
                        y = w < 0;
                        x += f*v;
                        d += f;
                        e -= f;
                        f = F;

                        h = x*M[(I+1)%N][(y ? J-- : ++J)%N][0];
                        c2 = M[I%N][J%N];
                        h += (1-x)*(y ? c1 : c2)[0];
                    }
                    (nn == NN) && console.log(I, J, y, M[I%N][(J+1)%N]);

                    z = (Z-h)/d-100; // height on screen from perspective calcultaions

                    if (z < m) {
                        if (p != q) {
                            m < n && R[q].push(n-m, k, n = m, S);
                            q = p;
                        }
                        m = z;
                    }

                    p = Math.min(31, c2[1]+2*(nn == NN)); // next cell's color
                    c1 = c2;

                }

                m < n && R[q].push(n-m, k, m, S); // push last rect in pipe
            }

            // fillrects grouped by color context
            for (
                k = 0;
                k < 32;
                k++
            ) {
                f = k<<3;
                c.fillStyle = 'rgb('+f+','+f+','+f+')';

                for (
                    j = 0, r = R[k];
                    h = r[j++];
                ) {
                    c.fillRect(r[j++], r[j++], r[j++], h+1);
                }
            }
        </script>
    </body>
</html>
