<!doctype html>
<html>
    <head>
        <title>Raycaster</title>
        <meta charset="utf-8" />
        <style>
            #fps {
                position: absolute;
                top: 0;
            }
        </style>
    </head>
    <body style="margin: 0px; overflow: hidden; background-color: #fff">
        <canvas></canvas>
        <div id="fps"></div>
        <script>
            var a = document.getElementsByTagName('canvas')[0];
            var b = document.body;
            var d = function(e) { return function() { e.parentNode.removeChild(e) } }(a);

            // unprefix some popular vendor prefixed things (but stick to their original name)
            var AudioContext = window.AudioContext
                || window.webkitAudioContext;
            var requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(f) { setTimeout(f, 1000/30) };

            // stretch canvas to screen size (once, wont onresize!)
            a.style.width = (a.width = innerWidth) + 'px';
            a.style.height = (a.height = innerHeight) + 'px';
            var c = a.getContext('2d');
        </script>
        <script>
            // Improvements:
            // * distance fog
            // * roads /rivers
            // * buildings
            // * biomes: plain+fields+fences+raods+villages, monument valley+canyon+river,
            // * biomes: mountains+forests+rivers+castles+snow, ocean+cliffs+beaches+islands, city+skyscrapers+streets
            // * clouds
            // * head-up indicators
            // * keep aspect ratio
            // * more colors
            // * one-dimension array for fillRects
            // * skip small fillRects
            // * V = f(Z)
            // * direction of light/normals
            // * variable width for fillRects

            var fps = (function(id) {
                    var fpsd = document.getElementById(id),
                        fpsl = 10,
                        fpss = new Array(fpsl),
                        fpsi = 0,
                        sum = 0,
                        oldtime = +new Date;
                    return function(time) {
                        fpsd.innerHTML = 0|(sum += -(fpss[fpsi%fpsl] || 0) + (fpss[fpsi++%fpsl] = 1000/(-oldtime+(oldtime = time))))/fpsl; // nb. frames/s (sliding window)
                    };
                })('fps');

            W = a.width/2;
            H = a.height/2;
            A = Math.PI/4;
            S = 0|W/150;
            Z = 120;
            N = 1<<10; // 1024
            X = Y = 0;
            C = 16;
            V = 5;
            AA = 0;
            ZZ = 0;
            F = 0; // 4 bits: left|up|right|down
            halt = false;

            onkeydown = onkeyup = function(e) {
                t = 1<<40-e.which;
                e.type[5] ? F |= t : F &= ~t;
                e.which == 32 && e.type[5] && (halt = !halt);
                //e.preventDefault(); // to make iframe integration easier, not part of the actual js1k entry
            };

            // rendering procedure ----------------------------------------
            setInterval(function() {

                if (!halt) {
                    A += AA += (F&2 ? -8 : F&8)/5E4;
                    V += (F&64 ? -128 : F&128)/1E3;
                    Z += V*Math.sin(ZZ += (F&4 ? -1 : F&1)/5E1);
                    X += V*Math.cos(A);
                    Y += V*Math.sin(A);
                    K1 = AA*20;
                    K2 = H+ZZ*120-W*K1;

                    a.width = a.width;
                    R = [[], [], [], []];
                    for (k=0; k < 2*W; k += S) {
                        angle = A+Math.atan((1-k/W)/2);
                        zz = k*K1+K2; // roll + pitch simulation
                        /*hm = 50*Math.cos(angle*10);
                        c.fillStyle = '#555';
                        c.fillRect(k, H/2-50-hm, S, H/2+50+hm);*/

                        cos = Math.cos(angle);
                        cp = cos > 0;
                        sin = Math.sin(angle);
                        sp = sin > 0;
                        Di = C/Math.abs(cos);
                        Dj = C/Math.abs(sin);
                        x = X;
                        y = Y;
                        i = 0|x/C;
                        j = 0|y/C;
                        di = (cp ? C-X%C : X%C)*Di/C;
                        dj = (sp ? C-Y%C : Y%C)*Dj/C;

                        h1 = hh = 2*H; // current screen y coordinate
                        c1 = 0; // current color
                        f = 0;

                        for (dd=0; dd < 1200; ) {
                            f = f ? f+1&3 : i%10 == 0 && j%10 == 0; // buildings

                            if (f^1) { // f != 1 && f != 3
                                if (di < dj) {
                                    dd += di;
                                    x = C*(cp ? ++i : i--);
                                    y += di*sin;
                                    dj -= di;
                                    di = Di
                                } else {
                                    dd += dj;
                                    y = C*(sp ? ++j : j--);
                                    x += dj*cos;
                                    di -= dj;
                                    dj = Dj;
                                }
                            }
                            if (f%3) { // f == 1 || f == 2
                                z = Z-150; // building height
                            } else {
                                z = Z-50-50*(Math.cos(x/50)*Math.cos(y/40)); // relative height = f(i, j, x, y)
                            }
                            h2 = H*z/dd+zz; // screen height
                            if (h2 < hh) {
                                c2 = f^1 ? (i^j)&1 : 3;
                                if (c2 != c1) { // add fillRect if color different from the previous one, else merge
                                    hh != h1 && R[c1].push(h1-hh+1, k, hh);
                                    h1 = hh;
                                    c1 = c2;
                                }
                                hh = h2;
                            } else {
                                //R[~c1&3].push(1, k, hh); // ridge line
                            }
                        }
                        R[c1].push(h1-hh+1, k, hh);

                        zz < hh && R[2].push(hh+1-zz, k, zz); // complete to horizon if necessary

                        // minimalist head-up display
                        R[3].push(S, W, H, S, W-AA*1E4, H-ZZ*100);
                    }
                    // group fillrects by color context
                    for (k=0; k<4; k++) {
                        f = 3*k;
                        c.fillStyle = '#'+f+f+f;
                        for (j=0, r = R[k] || []; h=R[k][j++]; ) {
                            c.fillRect(R[k][j++], R[k][j++], S, h);
                        }
                    }

                    fps(+new Date);
                }
            }, 33);
        </script>
    </body>
</html>
