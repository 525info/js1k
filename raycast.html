<!doctype html>
<html>
    <head>
        <title>Raycaster</title>
        <meta charset="utf-8" />
        <style>
            #fps {
                position: absolute;
                top: 0;
            }
            #coords {
                position: absolute;
                top: 20px;
            }
        </style>
    </head>
    <body style="margin: 0px; overflow: hidden; background-color: #fff">
        <canvas></canvas>
        <div id="fps"></div>
        <div id="coords"></div>
        <script>
            var a = document.getElementsByTagName('canvas')[0];
            var b = document.body;
            var d = function(e) { return function() { e.parentNode.removeChild(e) } }(a);

            // unprefix some popular vendor prefixed things (but stick to their original name)
            var AudioContext = window.AudioContext
                || window.webkitAudioContext;
            var requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(f) { setTimeout(f, 1000/30) };

            // stretch canvas to screen size (once, wont onresize!)
            a.style.width = (a.width = innerWidth) + 'px';
            a.style.height = (a.height = innerHeight) + 'px';
            var c = a.getContext('2d');
        </script>
        <script>
            // Improvements:
            // * biomes: plain+fields+fences+raods+villages, monument valley+canyon+river,
            // * biomes: mountains+forests+rivers+castles+snow, ocean+cliffs+beaches+islands, city+skyscrapers+streets
            // * runway+lift-off
            // * clouds
            // * keep aspect ratio
            // * more colors
            // * one-dimension array for fillRects
            // * skip small fillRects
            // * V = f(Z)
            // * AA = f(V)
            // * variable width for fillRects
            // * targets to shoot ?
            // * add functions to profile
            // * collisions ?
            // * primary color (2nd background) = f(biome)

            var fps = (function(id) {
                    var fpsd = document.getElementById(id),
                        fpsl = 10,
                        fpss = new Array(fpsl),
                        fpsi = 0,
                        sum = 0,
                        oldtime = +new Date;
                    return function(time) {
                        fpsd.innerHTML = 0|(sum += -(fpss[fpsi%fpsl] || 0) + (fpss[fpsi++%fpsl] = 1000/(-oldtime+(oldtime = time))))/fpsl; // nb. frames/s (sliding window)
                    };
                })('fps'),
                coords = document.getElementById('coords');

            W = a.width/2;
            H = a.height/2;
            M = [];
            N = 800;
            A = 1;
            S = 0|W/150;
            Z = 300;
            X = Y = 0;
            C = 16;
            V = 6;
            AA = 0;
            ZZ = 0;
            F = 0; // 4 bits: left|up|right|down
            halt = false;

            onkeydown = onkeyup = function(e) {
                t = 1<<40-e.which;
                e.type[5] ? F |= t : F &= ~t; // update the flag of down keys
                e.which == 32 && e.type[5] && (halt = !halt);
                //e.preventDefault(); // to make iframe integration easier, not part of the actual js1k entry
            };

            O = 400;
            P = [];
            R = [];

            for (n=0; n<O; n++)
                P.push(N*Math.random(), N*Math.random());

            for (i=0; i++<N; )
                for (M[i]=[], j=0; j++<N; ) {
                    v = [[0, N],[0, N]];
                    for (n=0; n<O; n++) {
                        dx = i - P[n*2];
                        dy = j - P[n*2+1];
                        d = Math.sqrt(dx*dx+dy*dy);
                        d < v[1][1] && (v = d < v[0][1] ? [[n, d] ,v[0]] : [v[0], [n, d]]);
                    }
                    M[i][j] = 2*(1-v[0][1]/v[1][1])*v[0][0];
                    /*r = f < .07 ? 128 : 0|f*v[0][0];
                    c.fillStyle = 'rgb('+r+','+r+','+r+')';
                    c.fillRect(i, j, 1, 1);*/
                }

            // rendering procedure ----------------------------------------
            setInterval(function(e) {

                if (!halt) {
                    A += AA += (F&2 ? -8 : F&8)/5E4;
                    //V += (F&64 ? -128 : F&128)/1E3;
                    Z += V*Math.sin(ZZ += (F&4 ? -1 : F&1)/5E1);
                    X += V*Math.cos(A);
                    Y += V*Math.sin(A);
                    K1 = AA*20;
                    K2 = H+ZZ*120-W*K1;

                    a.width = a.width; // canvas white reset

                    // fillrects grouped by color context
                    for (k=0; k++<32; ) {
                        f = k<<3;
                        c.fillStyle = 'rgb('+f+','+f+','+f+')';
                        for (j=0, r = R[k] || []; h=r[j++]; )
                            c.fillRect(r[j++], r[j++], r[j++], h);
                        R[k] = [];
                    }

                    for (k=0; k < 2*W; k += S) {
                        r = A+Math.atan((1-k/W)/2);
                        p = k*K1+K2; // roll + pitch simulation

                        Di = C/Math.abs(v = Math.cos(r));
                        Dj = C/Math.abs(w = Math.sin(r));
                        //x = X;
                        //y = Y;
                        i = 0|X/C;
                        j = 0|Y/C;
                        di = (v > 0 ? C-X%C : X%C)*Di/C;
                        dj = (w > 0 ? C-Y%C : Y%C)*Dj/C;

                        z0 = z1 = 2*H; // current screen y coordinate
                        c1 = 0; // current color

                        for (d=0; d < 5000; ) {

                            h = M[i] && M[i][j] || 0; //Math.min(500, M[i][j]);
                            if (di < dj) {
                                d += di;
                                //x = (v > 0 ? ++i : i--)<<4;
                                i += v > 0 ? 1 : -1;
                                //de = di*w;
                                //y += de;
                                dj -= di;
                                di = Di
                            } else {
                                d += dj;
                                //y = (w > 0 ? ++j : j--)<<4;
                                j +=  w > 0 ? 1 : -1;
                                //de = dj*v;
                                //x += de;
                                di -= dj;
                                dj = Dj;
                            }
                            z2 = H*(Z-50-h)/d+p; // height on screen from perspective calcultaions
                            if (z2 < z1) {
                                c2 = /*((i^j)&1)<<2*/ /*!(i%3 || j%3)+*/Math.min(31, 2*(!(i%7 || j%7) || h < 9)+Math.max(5, 0|(d-500)/80)/*+0|h/150*/);
                                if (c2 != c1) { // add fillRect if color different from the previous one, else merge
                                    z1 != z0 && R[c1].push(z0-z1+1, k, z1, S);
                                    z0 = z1;
                                    c1 = c2;
                                }
                                z1 = z2;
                            }
                        }

                        R[c1].push(z0-z1+1, k, z1, S); // push last rect in pipe

                        //zz < z1 && R[31].push(z1+1-zz, k, p, S); // complete to horizon if necessary

                        R[25].push(1, W-50, H-ZZ*100, 100, 100, W-AA*1E4, H-50, 1); // minimalist head-up display
                    }

                    fps(+new Date);
                    //coords.innerHTML = (0|X)+','+(0|Y);
                }
            }, 33);
        </script>
    </body>
</html>
