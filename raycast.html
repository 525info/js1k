<!doctype html>
<html>
    <head>
        <title>Raycaster</title>
        <meta charset="utf-8" />
        <style>
            #fps {
                position: absolute;
                top: 0;
                left: 10px;
            }
            #coords {
                position: absolute;
                top: 20px;
            }
        </style>
    </head>
    <body style="margin: 0px; overflow: hidden; background-color: #fff">
        <canvas></canvas>
        <div id="fps"></div>
        <div id="coords"></div>
        <script>
            var a = document.getElementsByTagName('canvas')[0];
            var b = document.body;
            var d = function(e) { return function() { e.parentNode.removeChild(e) } }(a);

            // unprefix some popular vendor prefixed things (but stick to their original name)
            var AudioContext = window.AudioContext
                || window.webkitAudioContext;
            var requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(f) { setTimeout(f, 1000/30) };

            // stretch canvas to screen size (once, wont onresize!)
            a.style.width = (a.width = innerWidth) + 'px';
            a.style.height = (a.height = innerHeight) + 'px';
            var c = a.getContext('2d');
        </script>
        <script>
            // * biomes: plain+fields+fences+raods+villages, monument valley+canyon+river,
            // * biomes: mountains+forests+rivers+castles+snow, ocean+cliffs+beaches+islands, city+skyscrapers+streets
            // * clouds
            // * keep aspect ratio
            // * more colors
            // * one-dimension array for fillRects
            // * targets to shoot ?
            // * primary color (2nd background) = f(biome)
            // * multi-level Voronoï
            // * collision detection
            // * variable background color
            // * autopilot, auto-height
            // * world switch when contact with item (light column ?)
            // * world seed => set of generation params (see level, montain shape & height, plateau height)
            // * poor perfs over water
            // * water color = f(depth) + foam
            // * scenery elements (bushes, rivers, rocks)
            // * buildings
            // * fog = f(z-h)
            // * variable LOD
            // * better perfs => less fillRects
            // * force cos(r) always > 0
            // * force X, Y always > 0
            // * progressive terrain generation
            // * terrain profile = f(I,J)
            // * profiles: flat, sea level, canyon, plateau
            // * transition between profiles (cos x)
            // * first profile = runway
            // * underwater
            // * improved ambient occlusion
            // * layers of colors
            // * merge rect with previous if dz < dz0
            // * beacon/lights to show the direction / head-up indicator
            // * permanent energy consumption
            // * large zones: interpolate (x²-1)², (X%N)/N, (Y%N)/N ?
            // * distance to target ?

            // * precise Z/V/C calculations
            // * V = f(Z)
            // * AA = f(V)
            // * auto dh = 0

            var fps = (function(id) {
                    var fpsd = document.getElementById(id),
                        fpsl = 10,
                        fpss = new Array(fpsl),
                        fpsi = 0,
                        sum = 0,
                        oldtime = +new Date;
                    return function(time) {
                        fpsd.innerHTML = 0|(sum += -(fpss[fpsi%fpsl] || 0) + (fpss[fpsi++%fpsl] = 1000/(-oldtime+(oldtime = time))))/fpsl; // nb. frames/s (sliding window)
                    };
                })('fps'),
                coords = document.getElementById('coords');

            H = (W = a.width = a.height)/2;
            M = [];         // terrain array
            N = 256;        // terrain size
            A =             // direction
            S = 3;          // pixel column width
            X = Y = 1e9;    // coordinates, forcd to positive values
            O = 100;        // initial energy
            B =             // direction 1st derivative
            Z =             // altitude
            K = 0;          // direction 2nd derivative
            R = [];         // color array

            halt = false;

            onkeydown = onkeyup = function(e) {
                K = e.which == 37 ? e.type[5] ? 2e-4 : 0 : e.which == 39 ? e.type[5] ? -2e-4 : 0 : K;
                e.which == 32 && e.type[5] && (halt = !halt);
                //e.preventDefault(); // to make iframe integration easier, not part of the actual js1k entry
            };

            // Voronoï terrain generation --------------------------------------

            // compute random set of points
            for (
                k = 0;
                k < N+N;
                k++
            )
                R.push([N*Math.random(), N*Math.random()]);

            // for each terrain cell, compute the two smallest distances (2nd order Voronoï)
            for (
                I = 0;
                I < N;
                I++
            )
                for (
                    M[I] = [], n = J = 0;
                    J <= N;
                    J++,
                    n = m
                ) {
                    for (
                        s = t = k = 0;
                        r = R[k];
                        k++
                    ) {
                        t += w = Math.pow(Math.hypot(
                            Math.min(d = Math.abs(I - r[0]), Math.abs(N-d)),
                            Math.min(d = Math.abs(J - r[1]), Math.abs(N-d))
                        ), -1.9);
                        s += k*w;
                    }

                    M[I%N][J%N] = [
                        m = Math.min(15, Math.max(0, s/t/7-35)), // altitude
                        14 + 9/(Math.abs(m-n)+1)           // color (pseudo ambient occlusion based on slope)
                    ];
                }

            // rendering procedure ----------------------------------------
            setInterval(function(e) {

                if (!halt/* && O*/) {
                    A += B += K;
                    X += Math.cos(A-.5);
                    Y += Math.sin(A-.5);

                    a.height = a.height; // canvas white reset

                    // draw fillrects grouped by color, to minimize number of fillStyle changes
                    for (
                        k = 0;
                        k < 32;
                        k++
                    ) {
                        f = k<<3;
                        c.fillStyle = 'rgb('+f+','+f+','+f+')';

                        for (
                            r = R[k];
                            h = r.shift();
                        )
                            c.fillRect(r.shift(), r.shift(), S, h+.5);

                    }

                    I = 0|X;
                    J = 0|Y;
                    t = Z-M[I%N][J%N][0]-3;
                    Z -= t > 0 ? .03 : .2*t;

                    for (
                        k = 0;
                        k < W;
                        k += S
                    ) {
                        P = (k-H)*B*30+H; // roll + pitch simulation

                        E = 1/Math.abs(v = H*Math.cos(r = A-k/W)); // approx: atan(x) ~ x for |x| < 0.4
                        F = 1/Math.abs(w = H*Math.sin(r));
                        I = 0|X;
                        J = 0|Y;
                        x = X-I;
                        y = Y-J;
                        u = M[I%N][J%N];
                        e = E*(v < 0 ? x : 1-x);
                        f = F*(w < 0 ? y : 1-y);

                        m = n = W; // screen y coordinate (current, next)
                        p = q = 20; // color (current, next)

                        for (
                            l = d = 0;
                            d < .2;
                        ) {

                            t = u;

                            g = e < f ? [ // [x, y, I, J, d, e, f]
                                x = v < 0,
                                y += e*w,
                                x ? I-- : ++I,
                                J+1,
                                e,
                                E,
                                f-e
                            ] : [ // [y, x, I, J, d, e, f]
                                y = w < 0,
                                x += f*v,
                                I+1,
                                y ? J-- : ++J,
                                f,
                                e-f,
                                F
                            ];

                            o = 0;
                            u = M[I%N][J%N]; // next cell
                            h = g[o++] ? t[0] : u[0];
                            h += g[o++]*(M[g[o++]%N][g[o++]%N][0] - h);
                            d += g[o++];
                            e = g[o++];
                            f = g[o++];

                            z = P-(h-Z)/d; // height on screen from perspective calculations
                            //d < .2 && Math.abs(k-H) <  10 && h > W && (W = h);

                            p = 0|Math.min(31, (h+l ? p : 17) + (d > .1 && d*200-20));
                            //r = 0|Math.min(31, u[1] + (d > .15 && d*200-30));

                            z < m && (
                                p != q && (r != q || p < r) && (
                                    n-m && R[q].push(n-m, k, n = m),
                                    q = p
                                ),
                                m = z
                            );

                            //p = r;
                            p = u[1];
                            l = h;

                        }

                        R[q].push(n-m, k, n = m); // push last rect in pipe
                    }
                    //R[23].push(O -= i > 0, W*(A + Math.atan2(Y, -X)), S); // energy gauge + target direction

                    fps(+new Date);
                }
            }, 33);
        </script>
    </body>
</html>
