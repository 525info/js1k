<!doctype html>
<html>
    <head>
        <title>Raycaster</title>
        <meta charset="utf-8" />
        <style>
            #fps {
                position: absolute;
                top: 0;
            }
            #coords {
                position: absolute;
                top: 20px;
            }
        </style>
    </head>
    <body style="margin: 0px; overflow: hidden; background-color: #fff">
        <canvas></canvas>
        <div id="fps"></div>
        <div id="coords"></div>
        <script>
            var a = document.getElementsByTagName('canvas')[0];
            var b = document.body;
            var d = function(e) { return function() { e.parentNode.removeChild(e) } }(a);

            // unprefix some popular vendor prefixed things (but stick to their original name)
            var AudioContext = window.AudioContext
                || window.webkitAudioContext;
            var requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(f) { setTimeout(f, 1000/30) };

            // stretch canvas to screen size (once, wont onresize!)
            a.style.width = (a.width = innerWidth) + 'px';
            a.style.height = (a.height = innerHeight) + 'px';
            var c = a.getContext('2d');
        </script>
        <script>
            // * biomes: plain+fields+fences+raods+villages, monument valley+canyon+river,
            // * biomes: mountains+forests+rivers+castles+snow, ocean+cliffs+beaches+islands, city+skyscrapers+streets
            // * clouds
            // * keep aspect ratio
            // * more colors
            // * one-dimension array for fillRects
            // * targets to shoot ?
            // * primary color (2nd background) = f(biome)
            // * why slower for V < 1 ?
            // * multi-level VoronoÃ¯
            // * collision detection
            // * variable background color
            // * autopilot, auto-height
            // * world switch when contact with item (light column ?)
            // * world seed => set of generation params (see level, montain shape & height, plateau height)
            // * poor perfs over water
            // * water color = f(depth) + foam
            // * scenery elements (bushes, rivers, rocks)
            // * buildings
            // * color pre-generation
            // * fog = f(z-h)
            // * black line bug
            // * variable LOD
            // * better perfs => less fillRects
            // * force cos(r) always > 0
            // * force X, Y always > 0
            // * progressive terrain generation
            // * terrain profile = f(I,J)
            // * profiles: flat, sea level, canyon, plateau
            // * transition between profiles (cos x)
            // * first profile = runway
            // * underwater
            // * odd line bug
            // * improved ambient occlusion
            // * layers of colors

            // * precise Z/V/C calculations
            // * V = f(Z)
            // * AA = f(V)
            // * auto dh = 0

            var fps = (function(id) {
                    var fpsd = document.getElementById(id),
                        fpsl = 10,
                        fpss = new Array(fpsl),
                        fpsi = 0,
                        sum = 0,
                        oldtime = +new Date;
                    return function(time) {
                        fpsd.innerHTML = 0|(sum += -(fpss[fpsi%fpsl] || 0) + (fpss[fpsi++%fpsl] = 1000/(-oldtime+(oldtime = time))))/fpsl; // nb. frames/s (sliding window)
                    };
                })('fps'),
                coords = document.getElementById('coords');

            H = (c.width = a.height)/2;
            M = [];
            N = 1<<8;
            A = 1.5;
            S = 5;
            //W =
            Z = 10;
            X = Y = 1e9;
            X += N/2;
            V = .4;
            B =
            C =
            D =
            K = 0; // 4 bits: left|up|right|down
            R = [];

            halt = false;

            onkeydown = onkeyup = function(e) {
                t = 1<<40-e.which;
                e.type[5] ? K |= t : K &= ~t; // update the flag of down keys
                e.which == 32 && e.type[5] && (halt = !halt);
                //e.preventDefault(); // to make iframe integration easier, not part of the actual js1k entry
            };

            for (
                k = 0;
                k < N/2;
            )
                R.push([N*Math.random(k++), N*Math.random(k++)]);

            for (
                i = 0;
                i < N;
                i++
            )
                for (
                    M[i] = [], n = j = 0;
                    j < N;
                    j++
                ) {
                    t = [];
                    for (
                        k = 0;
                        r = R[k];
                        k++
                    ) {
                        //d = Math.hypot(i - r[0], j - r[1]); // if not cycling
                        d = Math.hypot(
                            Math.min(d = Math.abs(i - r[0]), Math.abs(N-d)),
                            Math.min(d = Math.abs(j - r[1]), Math.abs(N-d))
                        );
                        t.splice(2*(d > t[1])+2*(d > t[3]), 0, k, d);
                    }
                    M[i][j] = [
                        m = Math.max(0, Math.min( 40, (m = (1-t[1]/t[3])*t[0]/9)*m -.1 )),
                        m ? 12 + 8/(Math.abs(m-n)+1) : 14
                    ];
                    n = m;
                }

            // rendering procedure ----------------------------------------
            setInterval(function(e) {

                if (!halt) {
                    A += B += (K&2 ? -8 : K&8)/8E4;
                    //V += (F&64 ? -128 : F&128)/1E3;
                    D += C += (K&4 ? -1 : K&1)/2E3;
                    Z += V*D; // approx: sin(x) ~ x for |x| < 0.5
                    X += V*Math.cos(D)*Math.cos(A);
                    Y += V*Math.cos(D)*Math.sin(A);
                    T = B*30;
                    U = H+D*600-H*T;

                    a.height = a.height; // canvas white reset

                    // fillrects grouped by color context
                    for (
                        nr = k = 0;
                        k < 32;
                        k++
                    ) {
                        f = k<<3;
                        c.fillStyle = 'rgb('+f+','+f+','+f+')';

                        for (
                            r = R[k];
                            h = r.shift();
                            nr++
                        )
                            c.fillRect(r.shift(), r.shift(), S, h+1);

                    }

                    for (
                        //W = -H,
                        k = 0;
                        k < 2*H;
                        k += S
                    ) {
                        r = A+(1-k/H)/2; // approx: atan(x) ~ x for |x| < 0.4
                        P = k*T+U; // roll + pitch simulation

                        E = 1/Math.abs(v = Math.cos(r)*H);
                        F = 1/Math.abs(w = Math.sin(r)*H);
                        I = X;
                        J = Y;
                        e = (t = I%1) ? E*(v > 0 ? 1-t : t) : E;
                        f = (t = J%1) ? F*(w > 0 ? 1-t : t) : F;

                        m = n = 2*H; // current screen y coordinate
                        p = q = 0; // current color

                        for (
                            d = 0;
                            d < .25;
                        ) {

                            if (o = e < f) {
                                I += -(t = I%1)+(v > 0 || -!t);
                                J += e*w;
                                h = M[i=~~I&255][j=~~J&255][0];
                                h += (M[i][j+1&255][0]-h)*(J%1) - Z;
                                d += e;
                                f -= e;
                                e = E;
                            } else {
                                I += f*v;
                                J += -(t = J%1)+(w > 0 || -!t);
                                h = M[i=~~I&255][j=~~J&255][0];
                                h += (M[i+1&255][j][0]-h)*(I%1) - Z;
                                d += f;
                                e -= f;
                                f = F;
                            }

                            z = P-h/d; // height on screen from perspective calculations
                            //d < .2 && Math.abs(k-H) <  10 && h > W && (W = h);

                            if (z < m) {
                                if (p != q) {
                                    m < n && R[q].push(n-m, k, m);
                                    n = m;
                                    q = p;
                                }
                                m = z;
                            }

                            p = 0|Math.min(31, Math.max(0, M[(i-(o && v < 0)+N)%N][(j-(!o && w < 0)+N)%N][1] + (d > .15 && d*200-30) /*+0|h/150*/));

                        }

                        m < n && R[q].push(n-m, k, m); // push last rect in pipe
                    }
                    //R[25].push(1, W-50, H/*-C*100*/, 100, 100, W/*-B*1E4*/, H-50, 1); // minimalist head-up display

                    fps(+new Date);
                    //coords.innerHTML = nr;
                }
            }, 25);
        </script>
    </body>
</html>
