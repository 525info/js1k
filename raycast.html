<!doctype html>
<html>
    <head>
        <title>Raycaster</title>
        <meta charset="utf-8" />
        <style>
            #fps {
                position: absolute;
                top: 0;
            }
        </style>
    </head>
    <body style="margin: 0px; overflow: hidden; background-color: #fff">
        <canvas></canvas>
        <div id="fps"></div>
        <script>
            var a = document.getElementsByTagName('canvas')[0];
            var b = document.body;
            var d = function(e) { return function() { e.parentNode.removeChild(e) } }(a);

            // unprefix some popular vendor prefixed things (but stick to their original name)
            var AudioContext = window.AudioContext
                || window.webkitAudioContext;
            var requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(f) { setTimeout(f, 1000/30) };

            // stretch canvas to screen size (once, wont onresize!)
            a.style.width = (a.width = innerWidth) + 'px';
            a.style.height = (a.height = innerHeight) + 'px';
            var c = a.getContext('2d');
        </script>
        <script>
            // Improvements:
            // * merge consecutive rects with same color
            // * distance fog
            // * roads /rivers
            // * buildings
            // * biomes: plain+fields+fences+raods+villages, monument valley+canyon+river,
            // * biomes: mountains+forests+rivers+castles+snow, ocean+cliffs+beaches+islands, city+skyscrapers+streets
            // * clouds
            // * head-up indicators
            // * keep aspect ratio
            // * more colors
            // * one-dimension array for fillRects
            // * skip small fillRects
            // * V = f(Z)
            // * direction of light/normals

            var fps = (function(id) {
                    var fpsd = document.getElementById(id),
                        fpsl = 10,
                        fpss = new Array(fpsl),
                        fpsi = 0,
                        sum = 0,
                        oldtime = +new Date;
                    return function(time) {
                        fpsd.innerHTML = 0|(sum += -(fpss[fpsi%fpsl] || 0) + (fpss[fpsi++%fpsl] = 1000/(-oldtime+(oldtime = time))))/fpsl; // nb. frames/s (sliding window)
                    };
                })('fps');

            W = a.width/2;
            H = a.height/2;
            A = Math.PI/4;
            S = 0|W/100;
            Z = 100;
            N = 1<<10; // 1024
            X = Y = 0;
            C = 16;
            V = 2;
            AA = 0;
            ZZ = 0;
            F = 0; // 4 bits: left|up|right|down
            halt = false;

            onkeydown = onkeyup = function(e) {
                t = 1<<40-e.which;
                e.type[5] ? F |= t : F &= ~t;
                e.which == 32 && e.type[5] && (halt = !halt);
                //e.preventDefault(); // to make iframe integration easier, not part of the actual js1k entry
            };

            // rendering procedure ----------------------------------------
            setInterval(function() {

                if (!halt) {
                    A += AA += (F&2 ? -8 : F&8)/5E4;
                    V += (F&64 ? -128 : F&128)/1E3;
                    Z += V*Math.sin(ZZ += (F&4 ? -1 : F&1)/5E1);
                    X += V*Math.cos(A);
                    Y += V*Math.sin(A);
                    K1 = AA*20;
                    K2 = ZZ*120;

                    a.width = a.width;
                    R = [[], [], [], []];
                    for (k=0; k < 2*W; k += S) {
                        angle = A+Math.atan((1-k/W)/2);
                        /*hm = 50*Math.cos(angle*10);
                        c.fillStyle = '#555';
                        c.fillRect(k, H/2-50-hm, S, H/2+50+hm);*/

                        cos = Math.cos(angle);
                        cp = cos > 0;
                        sin = Math.sin(angle);
                        sp = sin > 0;
                        Di = C/Math.abs(cos);
                        Dj = C/Math.abs(sin);
                        x = X;
                        y = Y;
                        i = 0|x/C;
                        j = 0|y/C;
                        di = (cp ? C-X%C : X%C)*Di/C;
                        dj = (sp ? C-Y%C : Y%C)*Dj/C;

                        hh = 2*H;
                        dd = 0;

                        for (s=0; dd < 1500; s++) {
                            if (di < dj) {
                                dd += di;
                                x = C*(cp ? ++i : i--);
                                y += di*sin;
                                dj -= di;
                                di = Di
                            } else {
                                dd += dj;
                                y = C*(sp ? ++j : j--);
                                x += dj*cos;
                                di -= dj;
                                dj = Dj;
                            }
                            z = 50+50*(Math.cos(x/50)*Math.cos(y/40)); // height = f(i, j, x, y)
                            color = (i^j)&1;
                            zz = (k-W)*K1+K2;
                            h = H+H*(Z-z)/dd+zz;
                            h < hh
                              ? R[color].push(hh-h, k, hh = h+1)
                              : false /*color == 3*/ ? R[2].push(1, k, hh) : 0; // ridge line
                        }
                        // to horizon
                        h = H+zz;
                        if (h < hh) {
                            R[2].push(hh-h, k, h);
                        }
                        // minimalist head-up display
                        //R[3].push(S, W, H, S, W-AA*1E4, H-ZZ*100);
                    }
                    // group fillrects by color context
                    for (k=0; k<4; k++) {
                        f = 3*k;
                        c.fillStyle = '#'+f+f+f;
                        for (j=0, r = R[k] || []; h=R[k][j++]; ) {
                            c.fillRect(R[k][j++], R[k][j++], S, h);
                        }
                    }

                    fps(+new Date);
                }
            }, 33);
        </script>
    </body>
</html>
