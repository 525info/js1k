<html>
    <head>
        <link href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.0.3/css/bootstrap.min.css" rel="stylesheet">
        <style>
            .description {
                margin-bottom: 15px;
            }
            canvas {
                float: left;
                border: 1px solid #bbb;
                width: 300px;
                height: 200px;
                margin-right: 20px;
            }
            .params {
                list-style-type: none;
                margin-bottom: 0;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="page-header">
                <h1><img src="http://js1k.com/2016-elemental/img/js1k-elemental.png" style="width: 60px; background-color: #fff"/>JS1K 2016 "???" post-mortem<small></small></h1>
            </div>
            <div class="row">
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Procedural terrain generation</h3>
                    </div>
                    <div class="panel-body">
                        <div class="description">The demo uses <a href="https://en.wikipedia.org/wiki/Inverse_distance_weighting">inverse distance weighting</a> to generate the terrain from a set of 2D random points.</div>
                        <canvas id="iso"></canvas>
                        <ul class="params">
                            <li><span>Nb. generator points/terrain size</span></li>
                            <li>Inverse distance power</li>
                            <li>Seamless borders</li>
                            <li>Factor</li>
                            <li>Minimum altitude</li>
                            <li>Maximum altitude</li>
                            <li>New set of points</li>
                            <li>Reset to entry values</li>
                            <li>Shading factor</li>
                            <li>Rocks</li>
                        </ul>
                    </div>
                </div>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Rendering</h3>
                    </div>
                    <div class="panel-body">
                        <div class="description">The demo implements an efficient <a href="https://en.wikipedia.org/wiki/Ray_casting">ray casting</a> algorithm.</div>
                        <canvas></canvas>
                        <ul class="params">
                            <li>POV angle</li>
                            <li>Distant fog</li>
                            <li>Interpolation</li>
                            <li>Water</li>
                            <li>Color grouping</li>
                            <li>Rects merging</li>
                            <li>Hidden rects</li>
                            <li>Variable column width</li>
                            <li>Pseudo-rolling</li>
                        </ul>
                    </div>
                </div>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Control</h3>
                    </div>
                    <div class="panel-body">
                        <div class="description">The demo uses a single function that serves as both onkeydown and onkeyup handler, and keeps track of the key states as digits of an integer.</div>
                        <canvas></canvas>
                        <ul class="params">
                            <li>Auto height</li>
                            <li>Keyboard state with binary flags</li>
                        </ul>
                    </div>
                </div>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Code golfing</h3>
                    </div>
                    <div class="panel-body">
                        <div class="description">The demo uses a minifier (jsCompress) and an entropic compressor (RegPack) that bring a xxx ratio.</div>
                        <canvas></canvas>
                        <ul class="params">
                            <li>JSCompress+Regpack</li>
                            <li>atan approximation</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <script>
            var
                points = function(nb) {
                    var P = [],
                        k;

                    for (k = 0; k < nb; k++) {
                        P[k] = [Math.random(), Math.random()];
                    }

                    return P;
                },
                terrain = function(points, params) {
                    var T = [], // 2D terrain
                        N = params.size,
                        Ng = points.length,
                        i, j, k,
                        d, di, dj,
                        w, s, t,
                        m, n;

                    // for each terrain intersection, compute the height
                    for (i = 0; i < N; i++) {
                        T[i] = [];
                        n = 0;
                        for (j = N+1; j; j--) {
                            // Combine the weighted influence of all generator points
                            s = 0; // sum of all weighted altitudes
                            t = 0; // sum of all weights
                            for (
                                k = 0;
                                k < Ng;
                                k++
                            ) {
                                g = points[k];
                                di = Math.hypot(i - N*g[0]);
                                dj = Math.hypot(j - N*g[1]);
                                d = params.seamless ? Math.hypot(
                                    Math.min(di, Math.hypot(N-di)),
                                    Math.min(dj, Math.hypot(N-dj))
                                ) : Math.hypot(di, dj);
                                w = Math.pow(d, params.power); // weight based on distance
                                t += w;
                                s += (k-Ng/2)*w; // the generator point altitude is its index in array
                            }
                            // Store the altitude and shading
                            m = s/t/params.factor+(params.rocks && Math.random() < 0.1 && Math.random()); // altitude
                            T[i%N][j%N] = [
                                m = Math.min(params.maxAlt, Math.min(params.minAlt, m)), // truncate
                                Math.atan(n-m) // shading factor based on slope
                            ]
                            n = m; // remember current altitude to compute slope between points
                        }
                    }
                    return T;
                },
                raycast = function(terrain, X, Y, angle, dmax, projection, params) {
                    var N = terrain.length,
                        v = Math.cos(angle),
                        w = Math.sin(angle),
                        E = 1/Math.hypot(v),
                        F = 1/Math.hypot(w),
                        I = 0|X,
                        J = 0|Y,
                        Z = 0,
                        u = terrain[I%N][J%N],
                        x = X-I,
                        y = Y-J,
                        e = E*(v < 0 ? x : 1-x),
                        f = F*(w < 0 ? y : 1-y),
                        n = m = 0, // screen y coordinate (current, next)
                        q = p = u[1], // color (current, next)
                        rects = [];

                    for (
                        l = d = 0;
                        d < dmax;
                    ) {
                        t = u;

                        g = e < f ? [ // [x, y, I, J, d, e, f]
                            x = v < 0,
                            y += e*w,
                            x ? I-- : ++I,
                            J+1,
                            e,
                            E,
                            f-e
                        ] : [ // [y, x, I, J, d, e, f]
                            y = w < 0,
                            x += f*v,
                            I+1,
                            y ? J-- : ++J,
                            f,
                            e-f,
                            F
                        ];

                        o = 0;
                        u = terrain[I%N][J%N]; // next cell
                        h = g[o++] ? t[0] : u[0];
                        h += g[o++]*(terrain[g[o++]%N][g[o++]%N][0] - h);
                        d += g[o++];
                        e = g[o++];
                        f = g[o++];

                        z = projection(d, 0/*h*/); // height on screen from perspective calculations

                        p = 0|h+l ? 15+6*p : 10;

                        z > m && (
                            p-q && m-n && (
                                rects.push([q, m-n]),
                                n = m,
                                q = p
                            ),
                            m = z
                        );

                        p = u[1];
                        l = h;

                    }

                    rects.push([q, m-n]); // push last rect in pipe

                    return rects;
                },
                isoProjection = function(distance, height) {
                    return distance*Math.SQRT1_2+height;
                },
                isoRender = function(terrain, canvas, params) {
                    var W = canvas.width,
                        H = canvas.height,
                        N = params.size,
                        w = W/2,
                        margin = W/20,
                        i, j,
                        ctx = canvas.getContext('2d'),
                        rects,
                        x, y,
                        h;

                    for (x = margin; x < W-margin; x += 2) {
                        l = N*(x-w)/(w-margin);
                        i = Math.max(0, l);
                        j = Math.max(0, -l);
                        rects = raycast(terrain, i, j, Math.PI/4, 2*(N-i-j)*Math.cos(Math.PI/4), isoProjection, {});
                        y = isoProjection((i+j)*Math.SQRT2, 0);
                        rects.forEach(function(rect) {
                            color = rect[0]<<3;
                            ctx.fillStyle = 'rgb('+color+','+color+','+color+')';
                            y -= h = rect[1];
                            ctx.fillRect(x, H-margin-y, 2, h);
                        });
                    }
                };

            var
                t = terrain(points(10), {
                    size: 10,
                    seamless: true,
                    power: -2,
                    factor: 1/9,
                    minAlt: 0,
                    maxAlt: 20,
                    rocks: true
                }),
                canvas = document.getElementById('iso');

            isoRender(t, canvas, {size: 10});
        </script>
    </body>
</html>
