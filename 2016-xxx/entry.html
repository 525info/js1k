<!doctype html>
<html>
    <head>
        <title>Raycaster</title>
        <meta charset="utf-8" />
        <style>
            body {
                text-align: center;
            }
            #fps {
                position: absolute;
                top: 0;
                left: 10px;
            }
        </style>
    </head>
    <body style="margin: 0px; overflow: hidden; background-color: #fff">
        <canvas></canvas>
        <div id="fps"></div>
        <script>
            var a = document.getElementsByTagName('canvas')[0];
            var b = document.body;
            var d = function(e) { return function() { e.parentNode.removeChild(e) } }(a);

            // unprefix some popular vendor prefixed things (but stick to their original name)
            var AudioContext = window.AudioContext
                || window.webkitAudioContext;
            var requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(f) { setTimeout(f, 1000/30) };

            // stretch canvas to screen size (once, wont onresize!)
            a.style.width = (a.width = innerWidth) + 'px';
            a.style.height = (a.height = innerHeight) + 'px';
            var c = a.getContext('2d');
        </script>
        <script>
            // * raycast bands bottom: low-res / middle: high-res
            // * use Math.{clz32, cbrt, expm1/log1p, hyp functions}
            // * V = f(A)
            // * transparent fence
            // * better-looking base
            // * track back landmark
            // * water level

            var fps = (function(id) {
                    var fpsd = document.getElementById(id),
                        fpsl = 10,
                        fpss = new Array(fpsl),
                        fpsi = 0,
                        sum = 0,
                        oldtime = +new Date;
                    return function(time, x, y) {
                        fpsd.innerHTML = (0|(sum += -(fpss[fpsi%fpsl] || 0) + (fpss[fpsi++%fpsl] = 1000/(-oldtime+(oldtime = time))))/fpsl)+' '+x+'/'+y; // nb. frames/s (sliding window)
                    };
                })('fps');

            W = a.height;
            H = W/2;
            a.style.width = (a.width = W) + 'px';
            D = 180/H;
            R = [L = D/2];         // color array
            M = [N = 250];         // terrain array
            //N        // terrain size => nb. points = 220
            //S             // variable pixel column width
            A = 2;            // direction
            B =             // direction 1st derivative
            Z =             // altitude
            V =             // speed
            K = 0;          // keyboard state
            X = Y = 1E9;

            onkeydown = onkeyup = function(e) {
                K = e.which == 37 ? e.type[5] ? 2E-4 : 0 : e.which == 39 ? e.type[5] ? -2E-4 : 0 : K;
                //e.preventDefault(); // to make iframe integration easier, not part of the actual js1k entry
            };

            // Inverse distance weighting --------------------------------------

            // compute random set of points
            for (
                k = 0;
                k < 350;
                k++
            )
                R[k] = [N*Math.random(), N*Math.random()];

            // for each terrain intersection, compute the height
            for (
                I = 0;
                I < N;
                I++
            )
                for (
                    M[I] = [J = N+1], n = 0;
                    J;
                    J--,
                    n = m
                ) {
                    for (
                        s = t = k = 0;
                        Q = R[k];
                        k++
                    ) {
                        t += w = Math.pow(Math.hypot(
                            Math.min(i = Math.hypot(I-Q[0]), Math.hypot(N-i)),
                            Math.min(i = Math.hypot(J-Q[1]), Math.hypot(N-i))
                        ), -2);
                        s += k*w;
                    }

                    m = s/t/12;
                    M[I%N][J%N] = [
                        10 + 4*(0|m/4),
                        m += Math.random() < 0.1 && Math.random(), // altitude
                        8 - 5*Math.atan(n-m)
                    ]
                }
            console.log(mm/N/N);

            Q = [X, Y];    // coordinates, forced to positive values

            // rendering procedure ----------------------------------------
            setInterval(function(e) {
                a.height = a.height; // canvas white reset

                // draw fillrects grouped by color, to minimize number of fillStyle changes
                for (
                    k = 0;
                    k < 50;
                    k++
                )
                    for (
                        u = R[k],
                        c.fillStyle = 'hsl(28,50%,'+k*3+'%)';
                        h = u.shift();
                    )
                        c.fillRect(u.shift(), u.shift(), u.shift(), h+1);

                for (
                    k = 0;
                    k < W;
                    k += S
                ) {
                    S = 0|Math.hypot(k-H+2E4*B)/50+2;
                    P = V*(k-H)*B*50+H; // roll + pitch simulation

                    E = 1/Math.hypot(v = H*Math.cos(r = A-k/W)); // approx: atan(x) ~ x for |x| < 0.4
                    F = 1/Math.hypot(w = H*Math.sin(r));
                    I = 0|X;
                    J = 0|Y;
                    u = M[I%N][J%N];
                    x = X-I;
                    y = Y-J;
                    e = E*(v < 0 ? x : 1-x);
                    f = F*(w < 0 ? y : 1-y);

                    n = m = W; // screen y coordinate (current, next)
                    q = p = u[2]; // color (current, next)

                    j = u[Math.hypot(I-Q[0]) > N | Math.hypot(J-Q[1]) > N]+5 - Z;

                    for (
                        l = d = 0;
                        d < D;
                    ) {

                        t = u;

                        g = e < f ? [ // [x, y, I, J, d, e, f]
                            x = v < 0,
                            y += e*w,
                            x ? I-- : ++I,
                            J+1,
                            e,
                            E,
                            f-e
                        ] : [ // [y, x, I, J, d, e, f]
                            y = w < 0,
                            x += f*v,
                            I+1,
                            y ? J-- : ++J,
                            f,
                            e-f,
                            F
                        ];
                        i = Math.hypot(I-Q[0]) > N | Math.hypot(J-Q[1]) > N;

                        o = 0;
                        u = M[I%N][J%N]; // next cell
                        h = g[o++] ? t[i] : u[i];
                        h += g[o++]*(M[g[o++]%N][g[o++]%N][i] - h) - Z;
                        //i == N && (h = 40);
                        d += g[o++];
                        e = g[o++];
                        f = g[o++];

                        z = P-h/d; // height on screen from perspective calculations

                        p = 0|p + (d > L && (d - L)*(33 - p)/L);

                        z < m && (
                            p-q && n-m && R[q].push(n-m, k, n = m, S),
                            q = p,
                            m = z
                        );

                        p = u[2];
                        l = h;

                    }

                    R[q].push(n-m, k, n = m, S); // push last rect in pipe
                }

                A += B += K;
                V += (1/(1+B*4E4*B)-V)/160;
                X += V*Math.cos(r = A-0.5);
                Y += V*Math.sin(r);
                Z += j/20;

                fps(+new Date, 0|X-Q[0], 0|Y-Q[1]);
            }, 33);
        </script>
    </body>
</html>
